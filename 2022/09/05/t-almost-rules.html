
<!DOCTYPE html>
<html lang='en-US'>
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>[Translation] Almost Rules</title>
  <meta name="description" content="看到的一篇博客，翻译学习记录一下。">
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="canonical" href="https://eluvk.github.io/2022/09/05/t-almost-rules.html">
  <link rel="alternate" type="application/rss+xml" title="EluvK" href="https://eluvk.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'Open Sans'; src: url('/css/OpenSans-300-Normal.woff2') format('woff2');
    font-weight: 300; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'JetBrains Mono'; src: url('/css/JetBrainsMono-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Normal.woff2') format('woff2');
    font-weight: 400; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-400-Italic.woff2') format('woff2');
    font-weight: 400; font-style: italic;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Normal.woff2') format('woff2');
    font-weight: 700; font-style: normal;
  }
  @font-face {
    font-family: 'EB Garamond'; src: url('/css/EBGaramond-700-Italic.woff2') format('woff2');
    font-weight: 700; font-style: italic;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  body {
    max-width: 100ch;
    padding: 4ch;
    margin-left: auto;
    margin-right: auto;
  }

  header { margin-bottom: 2rem; }
  header > nav { display: flex; column-gap: 2ch; align-items: baseline; flex-wrap: wrap; }
  header a { font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { margin-top: 2rem; }
  footer > p { display: flex; column-gap: 2ch; justify-content: center; flex-wrap: wrap; }
  footer a { color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
  <script type="text/javascript" id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">EluvK</a>
      <a href="/shortcuts.html">ShortCuts</a>
      <a href="/about.html">About</a>
      <!-- 
      <a href="/resume.html">Resume</a>
      <a href="/links.html">Links</a> 
      -->
    </nav>
  </header>

  <main>
  <article >

    <h1>
    <a href="#Translation-Almost-Rules"><span>[Translation] Almost Rules</span> <time datetime="2022-09-05">Sep 5, 2022</time></a>
    </h1>
<section id="s-1">

    <h2>
    <a href="#s-1"><span>零</span> </a>
    </h2>
<p><span>看到的一篇博客，翻译学习记录一下。</span></p>
<p><span>原文地址 : </span><a href="https://matklad.github.io/2022/07/10/almost-rules.html"><span>Almost Rules</span></a><span> by matklad</span></p>
</section>
<section id="s-2">

    <h2>
    <a href="#s-2"><span>序</span> </a>
    </h2>
<p><span>对软件来说最重要的边界就是对外接口。对外接口是用户直接交互的部分，因此你必须保证其向后兼容。</span></p>
<p><span>对于 web 服务，这个边界是 URL 的格式(scheme)和 JSON 请求和返回的字段格式；对于命令行应用，这个边界是所有命令行参数的集合和含义；对于系统内核，这个边界是系统调用的集合(Linux)或者 用户库 </span><code>user-space libraries</code><span> (Mac)。而对于一个编程语言，这个边界是其语言本身的定义：语法和语义。</span></p>
<p><span>有时候，作为宏观层面上的模式，人工的安插一些内部的边界是有好处的。边界会有很高的成本，但是它可以预防变化。巧妙地设置内部边界，甚至使边界变成外部接口是有用的。</span></p>
<p><span>边界把系统一分为二，并且如果边界本身的大小和整个系统的大小相比很小的话（类似于沙漏形状），那么就很容易通过边界来理解整个系统。</span></p>
<p><strong><span>仅仅</span></strong><span>理解边界就可以让你想象出在其下的子系统应该是怎么实现的。大多数适合，你想象的版本和实际情况会很接近，而且这张虚拟的思维导图会帮助你剥离胶水代码层，理解其中真正的核心逻辑。</span></p>
<p><span>不同于外部边界，一个内部的边界，即使一开始被设置在很好的地方，也有很高的风险被破坏。因为内部边界本质上不那么实体。大多数情况下可能就是一条不正式的规则，“比如模块 A 不应该包含模块 B” 。而有时候就很难注意到这些边界被破坏。这也是我为什么认为大公司能够从微服务架构中获益，虽然理论上如果我们协调好人员协助的问题，一个单体架构也能非常清晰甚至提供更好的性能。但是实践中，跨团队维护一个好的架构是很困难的，而如果把这些内部边界具化(reified)为流程，事情就变得简单些。</span></p>
<p><span>不仅很难去保证一个内部边界不被破坏，更大的问题是内部边界的存在本身，阻止了用户可见的系统特性。而为了保护内部边界的不被破坏，需要花费大量的权限保护，还导致了不能交付一些功能。</span></p>
<p><span>下面是我在 Rust 语言的发展过程中见到的，关于内部边界随着时间逐渐被侵蚀的案例。</span></p>
</section>
<section id="Namespaces">

    <h2>
    <a href="#Namespaces"><span>Namespaces</span> </a>
    </h2>
<p><span>这可能是 Rust 命名解析里一个晦涩的特性：Rust 里各种类、模块、Trait、变量，都会被纳入三种命名空间里：类型(type)、值(value)和宏(macro)。这允许了同时存在同名的事物而不冲突：</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">struct</span> <span class="hl-title class_">x</span> {}</span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">x</span>() {}</span></code></pre>

</figure>
<p><span>这个是合法的 Rust 代码，因为 </span><code>struct x</code><span> 是在类型命名空间里，而 </span><code>function x</code><span> 在值命名空间里。从语法上也能区分出来： </span><code>.</code><span> 用来遍历值命名空间， </span><code>::</code><span> 用来遍历类型命名空间。</span></p>
<p><span>虽然这几乎是一个规则了，但是还是出现了编译器放弃了这种清晰的语法下的命名空间规则、临时消除歧义(ah-hoc disambiguation)的例子。</span></p>
<p><span>比如这段代码：</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">use</span> std::<span class="hl-type">str</span>; <span class="hl-comment">// module `str`</span></span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">main</span>() {</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">s</span>: &amp;<span class="hl-type">str</span> = <span class="hl-type">str</span>::<span class="hl-title function_ invoke__">from_utf8</span>(<span class="hl-string">b&quot;hello&quot;</span>).<span class="hl-title function_ invoke__">unwrap</span>(); <span class="hl-comment">// s is type `str`</span></span>
<span class="line">    <span class="hl-type">str</span>::<span class="hl-title function_ invoke__">len</span>(s);</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>一共出现了4个 </span><code>str</code><span>, 前两个如同注释，理解起来很容易。后面两个：</span><code>str::from_utf8</code><span> 里，</span><code>str</code><span> 表示的是 module </span><code>str</code><span>，但是 </span><code>str::len(s)</code><span> 里 </span><code>str</code><span> 是 </span><strong><strong><span>type</span></strong></strong><span> </span><code>str</code><span>。</span></p>
<p><span>只要看一眼标准库的实现就会发现，大致结构如下：</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-comment">/// ....core/src/str/mod.rs</span></span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">const</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">from_utf8</span>(v: &amp;[<span class="hl-type">u8</span>]) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">Result</span>&lt;&amp;<span class="hl-type">str</span>, Utf8Error&gt; {</span>
<span class="line">    <span class="hl-comment">// implement!()</span></span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">impl</span> <span class="hl-title class_">str</span> {</span>
<span class="line">    <span class="hl-keyword">pub</span> <span class="hl-keyword">const</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">len</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> <span class="hl-type">usize</span> {</span>
<span class="line">        <span class="hl-keyword">self</span>.<span class="hl-title function_ invoke__">as_bytes</span>().<span class="hl-title function_ invoke__">len</span>()</span>
<span class="line">    }</span>
<span class="line">}</span></code></pre>

</figure>
<p><code>str::from_utf8</code><span> 是个独立的函数，所以使用 module </span><code>str</code><span>，而 module 继承自 类型命名空间，所以使用 </span><code>::</code><span> 十分合理。</span>
<span>而 </span><code>str::len</code><span> 是类型 </span><code>str</code><span> 的一个方法。而这里并没有显示的声明使用类型 </span><code>str</code><span>，所以正常来说，上面的 </span><code>str::len(s)</code><span> 的代码应该编译报错。但是编译器，还有 RA 都把这些基本类型的场景 hack 了。</span></p>
<p><span>自己写了一个同样的例子：非常正常的就报错了：</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">mod</span> mystr{</span>
<span class="line">    <span class="hl-keyword">pub</span> <span class="hl-keyword">struct</span> <span class="hl-title class_">mystr</span>;</span>
<span class="line">    <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">from_utf8</span>() <span class="hl-punctuation">-&gt;</span> mystr{</span>
<span class="line">        mystr{}</span>
<span class="line">    }</span>
<span class="line"></span>
<span class="line">    <span class="hl-keyword">impl</span> <span class="hl-title class_">mystr</span> {</span>
<span class="line">        <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">len</span>(&amp;<span class="hl-keyword">self</span>){}</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">test</span>() {</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">s</span> = mystr::<span class="hl-title function_ invoke__">from_utf8</span>();</span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">_</span> = s.<span class="hl-title function_ invoke__">len</span>(); <span class="hl-comment">// ok</span></span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">_</span> = mystr::mystr::<span class="hl-title function_ invoke__">len</span>(&amp;s); <span class="hl-comment">// ok</span></span>
<span class="line">    <span class="hl-keyword">let</span> <span class="hl-variable">_</span> = mystr::<span class="hl-title function_ invoke__">len</span>(s); <span class="hl-comment">// *compile error: cannot find function `len` in module `mystr`.*</span></span>
<span class="line">}</span></code></pre>

</figure>
</section>
<section id="Patterns-And-Expressions">

    <h2>
    <a href="#Patterns-And-Expressions"><span>Patterns And Expressions</span> </a>
    </h2>
<p><span>Rust 过去对模式(patterns)和表达式(expressions)用不同的语法类别作区分，任何语句，根据其上下文语义，都可以被准确的定义为是表达式或者模式。但是出现了一个小例外：</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">f</span>(value: <span class="hl-type">Option</span>&lt;<span class="hl-type">i32</span>&gt;) {</span>
<span class="line">  <span class="hl-keyword">match</span> value {</span>
<span class="line">    <span class="hl-literal">None</span> =&gt; (),</span>
<span class="line">    none =&gt; (),</span>
<span class="line">  }</span>
<span class="line">}</span></code></pre>

</figure>
<p><span>语法上， </span><code>None</code><span> 和 </span><code>none</code><span> 是无法区分的。实际扮演着不同的角色： </span><code>None</code><span> 指代 </span><code>Option::None</code><span> 这个常量，而 </span><code>none</code><span> 是引入的新的绑定。 Swift 通过强制要求对枚举的变量前加上一个 </span><code>.</code><span> ，优雅的消除了这种歧义。而 Rust 是直接在命名解析层面 hack 了这种情况：除非匹配到了范围内的常量，否则默认引入新绑定。</span></p>
<p><span>最近被 hack 的情况进一步放大：随着</span><a href="https://rust-lang.github.io/rfcs/2909-destructuring-assignment.html"><span>析构赋值</span></a><span>的实现，一个表达式可以直接被重定义为一个模式：</span></p>

<figure class="code-block">


<pre><code><span class="line"><span class="hl-keyword">let</span> (<span class="hl-keyword">mut</span> a, <span class="hl-keyword">mut</span> b) = (<span class="hl-number">0</span>, <span class="hl-number">1</span>)</span>
<span class="line">(a, b) = (b, a)</span></code></pre>

</figure>
<p><span>语法上， </span><code>=</code><span> 是二元表达式，所以其左端和右端应该都是表达式。但是现在左端 </span><code>(a, b)</code><span> 被重新定义为了模式。</span></p>
<p><span>也许，模式和表达式之间所谓的语法边界本身就是假的。应该从始至终就使用统一的表达式语法。</span></p>
<section id="s-3">

    <h3>
    <a href="#s-3"><code>::&lt;&gt;</code> </a>
    </h3>
<p><span>语法分类是仍然完好的边界，Rust 仍然是 </span><code>LL(k)</code><span> 语言: 可以通过一个单遍(</span><a href="https://en.wikipedia.org/wiki/One-pass_algorithm"><span>single-pass</span></a><span>)无须回溯的算法进行处理。代价就是我们不得不敲 </span><code>.collect::&lt;Vec&lt;_&gt;&gt;()</code><span> 而不是 </span><code>.collect&lt;Vec&lt;_&gt;&gt;()</code><span> （至今我也是仅仅敲 </span><code>.collect()</code><span> 然后通过自动补全来完成这个 </span><code>turbofish</code><span> 的语法。</span></p>
</section>
<section id="0-0">

    <h3>
    <a href="#0-0"><code>().0.0</code> </a>
    </h3>
<p><span>另外一个近期的变化是在此法分析器和解析器之间的边界的被破坏。</span></p>
<p><span>Rust 有元组类型 </span><code>tuple</code><span> ，并且使用 </span><code>.0</code><span> 这种可爱的语法来访问其有序的值域。这对于多层次的元组类型就是个问题。它们会出现类似于 </span><code>foo.1.2</code><span> 这样的语法。对于词法分析器来说，这个语法看起来就是 </span><code>foo</code><span> , </span><code>.</code><span> , </span><code>1.2</code><span> ，没错，</span><code>1.2</code><span> 是浮点数字。所以之前不得不把用一个额外的空格把表达式写成 </span><code>foo.1 .2</code></p>
<p><span>如今，这个特点被解析器 hack 住，从词法分析器里获取 </span><code>1.2</code><span> 这么个 </span><code>token</code><span>，分析其文本然后拆成 </span><code>1</code><span> 和 </span><code>.2</code><span> 两个 </span><code>token</code></p>
</section>
<section id="macros">

    <h3>
    <a href="#macros"><span>macros</span> </a>
    </h3>
<p><span>Rust 不同于许多编程语言，其词法分析器和解析器并不是模糊的内部边界，而是外部有服务保护的 API 的一部分。</span><code>tokens</code><span> 被塞进宏语句里，所以宏语句的效果取决于传入的 </span><code>tokens</code><span> 到底是如何拆分的。</span></p>
<p><span>虽然理论上，</span><code>tokens</code><span> 被宏获取的仅仅是其文字信息，但是在工程上，为了实现宏捕获字段（比如 </span><code>$x:expr</code><span>），一个 token 也可以是在编译器 AST 数据结构中的一个有完善结构的数据片段。</span></p>
<p><span>译注：这一段涉及编译原理，并没有看太懂..原文如下：</span></p>

<figure class="blockquote">
<blockquote><p><span>The last example is quite interesting: in Rust, unlike many programming languages, the separation between the lexer and the parser is not an arbitrary internal boundary, but is actually a part of an external, semver protected API. Tokens are the input to macros, so macro behavior depends on how exactly the input text is split into tokens.</span></p>
<p><span>And there’s a second boundary violation here: in theory, “token” as seen by a macro is just its text plus hygiene info. In practice though, to implement captures in macro by example ($x:expr things), a token could also be a fully-formed fragment of internal compiler’s AST data structure.</span></p>
<p><span>The API is carefully future proofed such that, as soon as the macro looks at such a magic token, it gets decomposed into underlying true tokens, but there are some examples where the internal details leak via changes in observable behavior.</span></p>
</blockquote>

</figure>
</section>
</section>
<section id="Lifetime-Parametricity">

    <h2>
    <a href="#Lifetime-Parametricity"><span>Lifetime Parametricity</span> </a>
    </h2>
<p><span>生命周期的参数化。</span></p>
<p><span>用一个正向一点的例子来结束这篇，在 Rust 里生命周期标注不会影响代码生成。实际上生命周期完全被从传递给 </span><code>codegen</code><span> 的数据里清理掉了。 尽管推断生命周期是不透明切难以弄清原因的，但是你可以确定值被 </span><code>dropped</code><span> 的确切位置和借用检查器的奇思妙想无关。</span></p>
</section>
<section id="Conclusion">

    <h2>
    <a href="#Conclusion"><span>Conclusion</span> </a>
    </h2>
<p><span>看起来我们通常都会对内部边界过于乐观，它们会在功能需求的压力下崩溃，除非有问题的边界被物理实体化。</span></p>
</section>
</article>
  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/EluvK/eluvk.github.io/edit/master/content/posts/2022-09-05-t-almost-rules.dj">
        <svg class="icon"><use href="/assets/icons.svg#edit"/></svg>
        Fix typo
      </a>
      <a href="/feed.xml">
        <svg class="icon"><use href="/assets/icons.svg#rss"/></svg>
        Subscribe
      </a>
      <a href="mailto:eluvk.dev+blog@gmail.com">
        <svg class="icon"><use href="/assets/icons.svg#email"/></svg>
        Get in touch
      </a>
      <a href="https://github.com/EluvK">
        <svg class="icon"><use href="/assets/icons.svg#github"/></svg>
        EluvK
      </a>
    </p>
  </footer>
</body>

</html>
